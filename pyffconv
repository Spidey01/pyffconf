#!/usr/bin/env python
"""
usage:

    pyffconv [options] {input file} {output file}

options:

    -f format       Override detected input format (ffmpeg -f).
    -F format       Override detected output format (ffmpeg -f).
    -i              Dump file information.

"""

#from subprocess import call
import subprocess
import sys

class Stream:
    """Interface to a streams info."""

    def __init__(self):
        pass

    def from_report(self, report):
        """Stream from Ffmpeg.report()."""

    def from_spec(self, spec):
        """From a Stream ... element of Ffmpeg.report()."""

class Ffmpeg:
    def __init__(self):
        pass

    def probe(self, path):
        """Query path with ffprobe and return output string."""
        return subprocess.check_output(["ffprobe", path], stderr=subprocess.STDOUT)


    def info(self, path, stream=subprocess.STDOUT):
        """Query path with ffprobe and write() to stream."""
        stream.write(self.probe(path))


    def report(self, path):
        """Return an array subset of probed informations."""
        slurp = False
        r = []
        for line in self.probe(path).split("\n"):

            if line.startswith('Input #0'):
                slurp = True

            if slurp and line.find('Duration: ') != -1:
                # r.append(line)
                r.append(line.strip())
                slurp = False

            if line.find('Stream #0:') != -1:
                slurp = False
                r.append(line.strip())

            if slurp:
                r.append(line)

        return r


    def convert(self, input_path, output_path):
        """Smart conversion of input_path to output_path."""

        args = ["/bin/echo",
            "ffmpeg",
            "-i", input_path,
        ]

        # Analyze streams and decide how to convert the thing.
        report = self.report(input_path)
        count_of_streams = 0

        for line in report:
            if line.startswith('Stream #0:'):
                count_of_streams += 1
                colon_fields = line.split(':')

                # the partition will make sure we skip things like '(eng)' in '1(eng)'
                stream_number = colon_fields[1].partition('(')

                # Audio, Video, Subtitle, Attachment. (That I know of.)
                stream_type =  colon_fields[2].strip()

                stream_data = colon_fields[3].strip()
                # strip whitepsace from fields by common.
                stream_data_fields = [ x.strip() for x in stream_data.split(',') ]


        args.append(output_path)

        subprocess.check_call(args)



# FIXME: if remainder == 1; returns []. > 1 works fine.
def parse_arguments(argv):
    """Return a dictionary of options and list of arguments.

    Options in the form -x are returned as key 'x' with value True.
    Remaining elements at end or after --, are returned as an array.
    """

    options = {}
    remainder = []

    for i in range(1, len(argv)-1):
        # print("i={0}".format(i))

        if argv[i].startswith('-'):
            # print("arg: "+argv[i])
            c = argv[i]
            if c in ('-i', '-r', '--debug'):
                options[c[1:]] = True
            elif c == '--':
                # print("--: end of options found")
                continue
        else:
            remainder = argv[i:]
            # print("remainder:")
            # for e in remainder:
                # print(e)
            # print('-------')
            break

    return (options, remainder)

def main(argv):
    """Program main entry point."""

    ffmpeg = Ffmpeg()

    file_list = []

    (options, file_list) = parse_arguments(argv)

    if options.has_key('-debug'):
        print("options:")
        for k in options.keys():
            print("\t{0} => {1}".format(k, options[k]))

        print("file_list:")
        for f in file_list:
            print("\t{0}".format(f))

    if options.has_key('i') or options.has_key('r'):
        for f in file_list:
            if options.has_key('i'):
                ffmpeg.info(f, sys.stdout)
            elif options.has_key('r'):
                print("Report for {0}".format(f))
                for elem in ffmpeg.report(f):
                    print(elem)
        sys.exit(0)

    if len(file_list) != 2:
        print("In conversion mode but file list given is not two paths.")
        length = len(file_list)
        print("length == {0}".format(length))
        if length == 0:
            print("A source input file is required.")
        if length < 2:
            print("A destination output file is required.")
        if length > 2:
            print("Too many files listed.")
        sys.exit(1)

    assert len(file_list) == 2
    ffmpeg.convert(*file_list)


if __name__ == "__main__":
    main(sys.argv)
