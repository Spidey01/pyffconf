#!/usr/bin/env python
"""
usage:

    pyffconv [options] {input file} {output file}

options:

    -f format       Override detected input format (ffmpeg -f).
    -F format       Override detected output format (ffmpeg -f).
    -i              Dump file information.

"""

import subprocess
import sys


class Stream: #{{{
    """Interface to a streams info."""


    def __init__(self, s_number, s_type, s_info): #{{{
        # strip whitepsace from fields by common.
        self.number = s_number
        self.type = s_type
        self.info = s_info
        self.info_fields = [ x.strip() for x in s_info.split(',') ]
    #}}}


    def __str__(self): #{{{
        return "( number={0}, type={1}, infos={2} )".format(self.number, self.type, self.info)
    #}}}


    @classmethod
    def from_report(cls, report): #{{{
        """Stream from Ffmpeg.report()."""

        streams = []
        for line in report:
            if line.startswith('Stream #0:'):
                streams.append(cls.from_spec(line))
        return streams

        #{{{
        # for line in report:
        #     if line.startswith('Stream #0:'):
        #         colon_fields = line.split(':')

        #         # the partition will make sure we skip things like '(eng)' in '1(eng)'
        #         stream_number = colon_fields[1].partition('(')[0]

        #         # Audio, Video, Subtitle, Attachment. (That I know of.)
        #         stream_type =  colon_fields[2].strip()

        #         stream_data = colon_fields[3].strip()
        #         # strip whitepsace from fields by common.
        #         stream_data_fields = [ x.strip() for x in stream_data.split(',') ]

        #         streams.append(Stream(stream_number, stream_type, stream_data))

        # return streams
        #}}}
    #}}}


    @classmethod
    def from_spec(cls, spec): #{{{
        """From a Stream ... element of Ffmpeg.report()."""

        if not spec.startswith('Stream #0:'):
            raise ArgumentError("Not a stream spec.")

        colon_fields = spec.split(':')

        # the partition will make sure we skip things like '(eng)' in '1(eng)'
        stream_number = colon_fields[1].partition('(')[0]

        # Audio, Video, Subtitle, Attachment. (That I know of.)
        stream_type =  colon_fields[2].strip()

        stream_data = colon_fields[3].strip()

        return Stream(stream_number, stream_type, stream_data)
    #}}}
#}}}


class Ffmpeg: #{{{
    def __init__(self): #{{{
        pass
    #}}}

    def probe(self, path): #{{{
        """Query path with ffprobe and return output string."""
        return subprocess.check_output(["ffprobe", path], stderr=subprocess.STDOUT)
    #}}}


    def info(self, path, stream=subprocess.STDOUT): #{{{
        """Query path with ffprobe and write() to stream."""
        stream.write(self.probe(path))
    #}}}


    def report(self, path): #{{{
        """Return an array subset of probed informations."""
        slurp = False
        r = []
        for line in self.probe(path).split("\n"):

            if line.startswith('Input #0'):
                slurp = True

            if slurp and line.find('Duration: ') != -1:
                # r.append(line)
                r.append(line.strip())
                slurp = False

            if line.find('Stream #0:') != -1:
                slurp = False
                r.append(line.strip())

            if slurp:
                r.append(line)

        return r
    #}}}


    def convert(self, input_path, output_path): #{{{
        """Smart conversion of input_path to output_path."""

        args = ["/bin/echo",
            "ffmpeg",
            "-i", input_path,
        ]

        # Analyze streams and decide how to convert the thing.
        streams = Stream.from_report(self.report(input_path))
        print("SOD")
        for stream in streams:
            # print(stream)
            print("stream=|{0}|".format(stream))
        print("EOF")


        args.append(output_path)

        subprocess.check_call(args)
    #}}}


    def _get_aac_args(self, stream, override_bitrate=None, override_comment=None, metadata={}): #{{{
        if stream.channels == 2: # stereo
            bitrate = '192k'
            comment = 'stereo'
        elif stream.channels > 2: # surround
            bitrate = "640k"
            comment = 'surround'
        else:
            return 'copy'

        bitrate = override_bitrate or bitrate
        comment = override_comment or comment

        p = 'aac -ab:{0} {1} -metadata:s:a:{2} "comment={3}"'.format(stream.number, bitrate, stream.number-1, comment)
        for k, v in metadata.items():
            p = p + ' -metadata:s:a:{0} "{1}={2}"'.format(stream.number-1, k, v)
        p = p + ' -strict experimental'

        return p
    #}}}


#}}}


# FIXME: if remainder == 1; returns []. > 1 works fine.
def parse_arguments(argv): #{{{
    """Return a dictionary of options and list of arguments.

    Options in the form -x are returned as key 'x' with value True.
    Remaining elements at end or after --, are returned as an array.
    """

    options = {}
    remainder = []

    for i in range(1, len(argv)-1):
        # print("i={0}".format(i))

        if argv[i].startswith('-'):
            # print("arg: "+argv[i])
            c = argv[i]
            if c in ('-i', '-r', '--debug'):
                options[c[1:]] = True
            elif c == '--':
                # print("--: end of options found")
                continue
        else:
            remainder = argv[i:]
            # print("remainder:")
            # for e in remainder:
                # print(e)
            # print('-------')
            break

    return (options, remainder)
#}}}


def main(argv): #{{{
    """Program main entry point."""

    ffmpeg = Ffmpeg()

    file_list = []

    (options, file_list) = parse_arguments(argv)

    if options.has_key('-debug'):
        print("options:")
        for k in options.keys():
            print("\t{0} => {1}".format(k, options[k]))

        print("file_list:")
        for f in file_list:
            print("\t{0}".format(f))

    if options.has_key('i') or options.has_key('r'):
        for f in file_list:
            if options.has_key('i'):
                ffmpeg.info(f, sys.stdout)
            elif options.has_key('r'):
                print("Report for {0}".format(f))
                for elem in ffmpeg.report(f):
                    print("elem=|{0}|".format(elem))
                    # print(elem)
            else:
                print("Internal error.")
        sys.exit(0)

    if len(file_list) != 2:
        print("In conversion mode but file list given is not two paths.")
        length = len(file_list)
        print("length == {0}".format(length))
        if length == 0:
            print("A source input file is required.")
        if length < 2:
            print("A destination output file is required.")
        if length > 2:
            print("Too many files listed.")
        sys.exit(1)

    assert len(file_list) == 2
    ffmpeg.convert(*file_list)
#}}}


if __name__ == "__main__": #{{{
    main(sys.argv)
#}}}
