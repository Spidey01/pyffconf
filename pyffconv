#!/usr/bin/env python
"""
usage:

    pyffconv [options] {input file} {output file}

options:

    -f format       Override detected input format (ffmpeg -f).
    -F format       Override detected output format (ffmpeg -f).
    -i              Dump file information (verbose).
    -r              Report stream information (terse).
    -C              Input audio is feature surround + commentary stereo.
    -d              Input audio is feature in surround + stereo.

"""

try:
    import argparse
except:
    print("You need to install the argparse module or upgrade to Python 2.7+.")
import re
import subprocess
import sys

#
# This will be set to the result of calling parse_arguments() by main().
#
Options = None

class Stream: #{{{
    """Interface to a streams info."""


    def __init__(self, s_number, s_type, s_info): #{{{
        # strip whitepsace from fields by common.
        self.number = s_number
        self.type = s_type
        self.info = s_info
        self.info_fields = [ x.strip() for x in s_info.split(',') ]
    #}}}


    def __str__(self): #{{{
        return "( number={0}, type={1}, infos={2} )".format(self.number, self.type, self.info)
    #}}}


    @classmethod
    def from_report(cls, report): #{{{
        """Stream from Ffmpeg.report()."""

        streams = []
        for line in report:
            if line.startswith('Stream #0:'):
                streams.append(cls.from_spec(line))
        return streams

        #{{{
        # for line in report:
        #     if line.startswith('Stream #0:'):
        #         colon_fields = line.split(':')

        #         # the partition will make sure we skip things like '(eng)' in '1(eng)'
        #         stream_number = colon_fields[1].partition('(')[0]

        #         # Audio, Video, Subtitle, Attachment. (That I know of.)
        #         stream_type =  colon_fields[2].strip()

        #         stream_data = colon_fields[3].strip()
        #         # strip whitepsace from fields by common.
        #         stream_data_fields = [ x.strip() for x in stream_data.split(',') ]

        #         streams.append(Stream(stream_number, stream_type, stream_data))

        # return streams
        #}}}
    #}}}


    @classmethod
    def from_spec(cls, spec): #{{{
        """From a Stream ... element of Ffmpeg.report()."""

        if not spec.startswith('Stream #0:'):
            raise ArgumentError("Not a stream spec.")

        colon_fields = spec.split(':')

        # the partition will make sure we skip things like '(eng)' in '1(eng)'
        stream_number = colon_fields[1].partition('(')[0]

        # Audio, Video, Subtitle, Attachment. (That I know of.)
        stream_type =  colon_fields[2].strip()

        stream_data = colon_fields[3].strip()

        return Stream(stream_number, stream_type, stream_data)
    #}}}
#}}}


class Ffmpeg: #{{{
    def __init__(self): #{{{
        pass
    #}}}

    def probe(self, path): #{{{
        """Query path with ffprobe and return output string."""
        return subprocess.check_output(["ffprobe", path], stderr=subprocess.STDOUT)
    #}}}


    def info(self, path, stream=subprocess.STDOUT): #{{{
        """Query path with ffprobe and write() to stream."""
        stream.write(self.probe(path))
    #}}}


    def report(self, path): #{{{
        """Return an array subset of probed informations."""
        slurp = False
        r = []
        for line in self.probe(path).split("\n"):

            if line.startswith('Input #0'):
                slurp = True

            if slurp and line.find('Duration: ') != -1:
                # r.append(line)
                r.append(line.strip())
                slurp = False

            if line.find('Stream #0:') != -1:
                slurp = False
                r.append(line.strip())

            if slurp:
                r.append(line)

        return r
    #}}}


    def convert(self, input_path, output_path): #{{{
        """Smart conversion of input_path to output_path."""

        args = ["/bin/echo",
            "ffmpeg",
            "-i", input_path,
        ]

        # Analyze streams and decide how to convert the thing.
        streams = Stream.from_report(self.report(input_path))
        print("SOD")
        for stream in streams:
            # print(stream)
            print("stream=|{0}|".format(stream))
        print("EOF")


        args.append(output_path)

        subprocess.check_call(args)
    #}}}


    def _get_libx264_args(self, crf=23, profile='high', preset='medium', level='4.1'): #{{{
        return "libx264 -crf {0} -profile:v {1} -preset {2} -level {3}".format(crf, profile, preset, level)
    #}}}


    # TODO replace override_comment with just using metadata['comment'].
    def _get_aac_args(self, stream, bitrate=None, metadata={}): #{{{
        if stream.channels == 2: # stereo
            bitrate = bitrate or '192k'
            comment = 'stereo'
        elif stream.channels > 2: # surround
            bitrate = bitrate or '640k'
            comment = 'surround'
        else:
            return 'copy'

        metadata['comment'] = metadata.get('comment', comment)

        p = 'aac -ab:{0} {1}'.format(stream.number, bitrate, stream.number-1)
        for k, v in metadata.items():
            p = p + ' -metadata:s:a:{0} "{1}={2}"'.format(stream.number-1, k, v)
        p = p + ' -strict experimental'

        return p
    #}}}


    def _get_aac_downmix_args(self, stream, bitrate=None, metadata={}): #{{{
        """Get flags to convert stream to aac, and downmix to stereo.

        If bitrate is None then a default will be used.
        """

        #
        # We override the title metadata because we're downmixing and ffmpeg
        # will just copy the old, which would usually be like 3/2+1 for 6
        # channels.
        #
        metadata['title'] = metadata.get('title', '2/0')
        metadata['comment'] = metadata.get('comment', 'downmixed')
        #
        # Seems ffmpeg can only go up to 576k here. Dunno why.  That's still
        # 72k (8 channel) to 95k (6 channel) worth of head room per channel. So
        # I'm sure that's enough space to avoid ditching too much data.
        #
        bitrate = bitrate or '576k'

        # could we reuse _get_acc_args here and keep ffmpeg happy?
        p = ''
        for k, v in metadata.items():
            p = p + ' -metadata:s:a:{0} "{1}={2}"'.format(stream.number-1, k, v)
        return 'aac {0} -ab:{1} {2} -filter:{1} aresample=matrix_encoding=dplii -ac:{1} 2 -strict experimental'.format(p, stream.number, bitrate)
    #}}}


#}}}


def parse_arguments(argv): #{{{
    """Return a object representing the arguments."""


    p = argparse.ArgumentParser(prog=argv[0],
            description="Convertion tool built in Python and using ffmpeg.")
    p.add_argument('--debug', action='store_true',
            help="For developers.")
    p.add_argument('-C', '--second-stream-is-commentary', action='store_true', dest='commentary_follows',
            help="Audio streams are surround feature followed by commentary.")
    p.add_argument('-F', '--output-format', dest='output_format', type=str, metavar='FORMAT',
            help="Force output container to be in FORMAT.")
    p.add_argument('-d', '--second-stream-is-downmixed', action='store_true', dest='downmix_follows',
            help="Audio streams are surround feature followed by already downmixed feature.")
    p.add_argument('-f', '--input-format', dest='input_format', type=str, metavar='FORMAT',
            help="Force input container to be detected as FORMAT.")
    p.add_argument('-i', '--information', action='store_true', dest='info',
            help="Verbose dump of file contents.")
    p.add_argument('-r', '--report', action='store_true', dest='report',
            help="Concise report of file contents.")
    p.add_argument('file_list', nargs=argparse.REMAINDER)

    args = p.parse_args(argv[1:])

    if args.debug:
        print("debug                => {0}".format(args.debug))
        print('commentary_follows   => {0}'.format(args.commentary_follows))
        print("output_format        => {0}".format(args.output_format))
        print('downmix_follows      => {0}'.format(args.downmix_follows))
        print("input_format         => {0}".format(args.input_format))
        print('info                 => {0}'.format(args.info))
        print('report               => {0}'.format(args.report))
        print('file_list            => {0}'.format(args.file_list))
        print('argv                 => {0}'.format(argv))

    return args
#}}}


def main(argv): #{{{
    """Program main entry point."""

    ffmpeg = Ffmpeg()
    Options = parse_arguments(argv)


    if Options.info or Options.report:
        for f in Options.file_list:
            if Options.info:
                ffmpeg.info(f, sys.stdout)
            elif Options.report:
                print("Report for {0}".format(f))
                for elem in ffmpeg.report(f):
                    print("elem=|{0}|".format(elem))
                    # print(elem)
            else:
                print("Internal error.")
        sys.exit(0)

    length = len(Options.file_list)
    if length != 2:
        print("In conversion mode but file list given is not two paths.")
        if Options.debug:
            print("length == {0}".format(length))

        if length == 0:
            print("A source input file is required.")
        if length < 2:
            print("A destination output file is required.")
        if length > 2:
            print("Too many files listed.")
        sys.exit(1)

    assert length == 2
    ffmpeg.convert(*Options.file_list)
#}}}


if __name__ == "__main__": #{{{
    main(sys.argv)
#}}}
