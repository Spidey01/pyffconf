#!/usr/bin/env python
"""
usage:

    pyffconv [options] {input file} {output file}

options:

    -f format       Override detected input format (ffmpeg -f).
    -F format       Override detected output format (ffmpeg -f).
    -i              Dump file information (verbose).
    -r              Report stream information (terse).
    -d stream       Input audio is srround and should become downmix+surround.

"""

try:
    import argparse
except:
    print("You need to install the argparse module or upgrade to Python 2.7+.")
import re
import subprocess
import sys

#
# This will be set to the result of calling parse_arguments() by main().
#
Options = None

class Stream: #{{{
    """Interface to a streams info."""

    T_VIDEO = "Video"
    T_AUDIO = "Audio"
    T_SUBTITLE = "Subtitle"
    T_ATTACHMENT = "Attachment"

    __channel_regex = re.compile('^\d.\d')

    def __init__(self, stream_line): #{{{
        """Create a object representing a Stream.

        The input is in the same format as a From a Stream ... element
        of Ffmpeg.report().
        """

        # XXX #0: should be more dynamic but this is fine in practice.
        if not stream_line.startswith('Stream #0:'):
            raise ArgumentError("Not a stream spec.")

        colon_fields = stream_line.split(':')


        #
        # Common things.
        #

        # the partition will make sure we skip things like '(eng)' in '1(eng)'
        self.number = int(colon_fields[1].partition('(')[0])

        # Audio, Video, Subtitle, Attachment. (That I know of.)
        self.type = colon_fields[2].strip()

        self.info = colon_fields[3].strip()
        self.info_fields = [ x.strip() for x in self.info.split(',') ]

        self.format = self.info_fields[0]

        # Audio things.

        # sample rate in hz
        self.rate = None
        if self.type == self.T_AUDIO:
            self.rate = self.info_fields[1].split()[0]

        self.channels = None
        if self.type == self.T_AUDIO:
            ch = self.info_fields[2]
            if ch == "stereo":
                self.channels = 2
            elif self.__channel_regex.match(ch):
                main, _, lfe = ch.partition('.')
                self.channels = int(main) + int(re.sub('\(.+', '', lfe))
            else:
                self.channels = ch
    #}}}


    def __str__(self): #{{{
        return """(
    number={0},
    type={1},
    format={2},
    channels={3},
    rate={4},
    info={5}
)""".format(self.number, self.type, self.format, self.channels, self.rate, self.info)
    #}}}


    @classmethod
    def from_report(cls, report): #{{{
        """Stream from Ffmpeg.report()."""

        streams = []
        for line in report:
            if line.startswith('Stream #0:'):
                streams.append(cls(line))
        return streams
    #}}}
#}}}


class Ffmpeg: #{{{
    def __init__(self): #{{{
        pass
    #}}}

    def probe(self, path): #{{{
        """Query path with ffprobe and return output string."""
        return subprocess.check_output(["ffprobe", path], stderr=subprocess.STDOUT)
    #}}}


    def info(self, path, stream=subprocess.STDOUT): #{{{
        """Query path with ffprobe and write() to stream."""
        stream.write(self.probe(path))
    #}}}


    def report(self, path): #{{{
        """Return an array subset of probed informations."""
        slurp = False
        r = []
        for line in self.probe(path).split("\n"):

            if line.startswith('Input #0'):
                slurp = True

            if slurp and line.find('Duration: ') != -1:
                # r.append(line)
                r.append(line.strip())
                slurp = False

            if line.find('Stream #0:') != -1:
                slurp = False
                r.append(line.strip())

            if slurp:
                r.append(line)

        return r
    #}}}


    def convert(self, options, input_path, output_path): #{{{
        """Smart conversion of input_path to output_path."""

        args = ["/bin/echo",
            "ffmpeg",
            "-i", input_path,
        ]

        # Analyze streams and decide how to convert the thing.
        streams = Stream.from_report(self.report(input_path))
        stream_count = len(streams)

        print("SOD")
        for s in streams:
            print("stream => {0}".format(s))

            map_arg = "-map 0:{0}".format(s.number)

            if s.type == Stream.T_VIDEO:
                args.append(map_arg)
                args.append(self._get_stream_args(s.number, s.type))
                args.append(self._get_libx264_args())

            elif s.type == Stream.T_AUDIO:
                #
                # problem:
                #
                #   We'll botch the next -map when doing the downmix.
                #   Maybe we should make a list of output Streams to feed everything with.
                #
                if s.channels > 2 and s.info.find('default') != -1:
                    # We'll do a downmix and a straight stream.

                    # We don't support this before stream 1.
                    assert s.number > 0

                    # Two -map instances so we have the extra stream in the output.
                    args.extend([map_arg, map_arg])

                    # The downmixed stereo copy of the stream.
                    args.append(self._get_stream_args(s.number, s.type))
                    args.append(self._get_aac_downmix_args(s))

                    # The surround copy of the stream.
                    args.append(self._get_stream_args(s.number+1, s.type))
                    args.append(self._get_aac_args(s))
                else:
                    # Just a straight stream.
                    args.append(map_arg)
                    args.append(self._get_stream_args(s.number, s.type))
                    args.append(self._get_aac_args(s))

        print("EOF")


        args.append(output_path)

        for a in args:
            print(a)
        # subprocess.check_call(args)
    #}}}

    def _get_stream_args(self, n, t): #{{{
        if t == Stream.T_VIDEO:
            return "-c:v:{0} ".format(n)
        elif t == Stream.T_AUDIO:
            return "-c:a:{0} ".format(n)
        raise ValueError("Invalid")
    #}}}


    def _get_libx264_args(self, crf=23, profile='high', preset='medium', level='4.1'): #{{{
        return "libx264 -crf {0} -profile:v {1} -preset {2} -level {3}".format(crf, profile, preset, level)
    #}}}


    # TODO replace override_comment with just using metadata['comment'].
    def _get_aac_args(self, stream, bitrate=None, metadata={}): #{{{
        if stream.channels == 2: # stereo
            bitrate = bitrate or '192k'
            comment = 'stereo'
        elif stream.channels > 2: # surround
            bitrate = bitrate or '640k'
            comment = 'surround'
        else:
            return 'copy'

        metadata['comment'] = metadata.get('comment', comment)

        p = 'aac -ab:{0} {1}'.format(stream.number, bitrate, stream.number-1)
        for k, v in metadata.items():
            p = p + ' -metadata:s:a:{0} "{1}={2}"'.format(stream.number-1, k, v)
        p = p + ' -strict experimental'

        return p
    #}}}


    def _get_aac_downmix_args(self, stream, bitrate=None, metadata={}): #{{{
        """Get flags to convert stream to aac, and downmix to stereo.

        If bitrate is None then a default will be used.
        """

        #
        # We override the title metadata because we're downmixing and ffmpeg
        # will just copy the old, which would usually be like 3/2+1 for 6
        # channels.
        #
        metadata['title'] = metadata.get('title', '2/0')
        metadata['comment'] = metadata.get('comment', 'downmixed')
        #
        # Seems ffmpeg can only go up to 576k here. Dunno why.  That's still
        # 72k (8 channel) to 95k (6 channel) worth of head room per channel. So
        # I'm sure that's enough space to avoid ditching too much data.
        #
        bitrate = bitrate or '576k'

        # could we reuse _get_acc_args here and keep ffmpeg happy?
        p = ''
        for k, v in metadata.items():
            p = p + ' -metadata:s:a:{0} "{1}={2}"'.format(stream.number-1, k, v)
        return 'aac {0} -ab:{1} {2} -filter:{1} aresample=matrix_encoding=dplii -ac:{1} 2 -strict experimental'.format(p, stream.number, bitrate)
    #}}}


#}}}


def parse_arguments(argv): #{{{
    """Return a object representing the arguments."""


    p = argparse.ArgumentParser(prog=argv[0],
            description="Convertion tool built in Python and using ffmpeg.")
    p.add_argument('--debug', action='store_true',
            help="For developers.")
    p.add_argument('-F', '--output-format', dest='output_format', type=str, metavar='FORMAT',
            help="Force output container to be in FORMAT.")
    p.add_argument('-f', '--input-format', dest='input_format', type=str, metavar='FORMAT',
            help="Force input container to be detected as FORMAT.")
    p.add_argument('-i', '--information', action='store_true', dest='info',
            help="Verbose dump of file contents.")
    p.add_argument('-r', '--report', action='store_true', dest='report',
            help="Concise report of file contents.")
    p.add_argument('-d', '--downmix', dest='downmix_from', type=int, metavar='STREAM_NUMBER',
            help="Create stereo downmix and surround from surround STREAM_NUMBER.")
    p.add_argument('-c', '--commentary', dest='commentary_from', type=int, metavar='STREAM_NUMBER',
            help="Mark STREAM_NUMBER as commentary.")

    p.add_argument('file_list', nargs=argparse.REMAINDER)

    args = p.parse_args(argv[1:])

    if args.debug:
        print("debug                => {0}".format(args.debug))
        print('commentary_from      => {0}'.format(args.commentary_from))
        print("output_format        => {0}".format(args.output_format))
        print('downmix_from         => {0}'.format(args.downmix_from))
        print("input_format         => {0}".format(args.input_format))
        print('info                 => {0}'.format(args.info))
        print('report               => {0}'.format(args.report))
        print('file_list            => {0}'.format(args.file_list))
        print('argv                 => {0}'.format(argv))

    return args
#}}}


def main(argv): #{{{
    """Program main entry point."""

    ffmpeg = Ffmpeg()
    Options = parse_arguments(argv)


    if Options.info or Options.report:
        for f in Options.file_list:
            if Options.info:
                ffmpeg.info(f, sys.stdout)
            elif Options.report:
                print("Report for {0}".format(f))
                for elem in ffmpeg.report(f):
                    print("elem=|{0}|".format(elem))
                    # print(elem)
            else:
                print("Internal error.")
        sys.exit(0)

    length = len(Options.file_list)
    if length != 2:
        print("In conversion mode but file list given is not two paths.")
        if Options.debug:
            print("length == {0}".format(length))

        if length == 0:
            print("A source input file is required.")
        if length < 2:
            print("A destination output file is required.")
        if length > 2:
            print("Too many files listed.")
        sys.exit(1)

    assert length == 2
    ffmpeg.convert(Options, *Options.file_list)
#}}}


if __name__ == "__main__": #{{{
    main(sys.argv)
#}}}
